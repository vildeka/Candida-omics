---
title: "Metagenome Quality Control and Normalization"
date: today
date-format: "D MMM YYYY"
format:
  html: 
    embed-resources: true
    toc: true
    toc-depth: 2
    highlight-style: github
    code-tools:
      source: true
      toggle: true
      caption: Code
---

## Overview: 
#### Quality Control and Normalization

1. **Step 1: Load data and meta data**  
   Load data and meta data and filter out any QC samples.

2. **Step 2: Taxonomical-filtering**  
   Identify treshold for low abundant taxa to filter<br>
   Step 1. Split clade name into seperate columns<br>
   Step 2. Identify the strains to remove<br>
   Step 3. Aggregate removed strains by higher levels<br>
   Step 4. Get longer format and add back clade_names<br>
   Step 5. Subtract filtered taxa from each higher taxa levels<br>
   Step 6: Re-normalize each sample to 100%<br>
   Step 7: Check and replace negative values with zero<br>

3. **Step 3: Simplify clade names**  

4. **Step 4: Centered Log Ratio (CLR) Transformation**

5. **Step 5: Exploratory Unsupervised PCA**

6. **Step 6: Exploratory Heatmap**

### Load Libraries
```{r Libraries}
#| code-fold: true
#| output: false
##################
# LOAD LIBRARIES #
##################
library(tidyverse)
library(mixOmics) 
library(readxl)
library(cowplot)
library(RColorBrewer)
library(scales)
select <- dplyr::select
map <- purrr::map

#################
# COLOUR PALLET #
#################
pal <- c("#902267", "#ffa998", "#f588af", "gray") # #e05e85
pal2 <- c("#f26386", "#f588af",  "#a4d984", "#5f983cff", "#fbbc52", "#fd814e", "gray") 

# setwd("/Users/vilkal/work/Brolidens_work/Projects/Candida-omics/src")

taxonomy <- c(
  "kingdom",
  "phylum",
  "class",
  "order",
  "family",
  "genus",
  "species",
  "strain"
)
```

The first part of this script follows the preprocessing steps outlined on the MixOmics tutorial
https://mixomics.org/mixmc/mixmc-preprocessing/

## Step 1: Load data

```{r Load-data}
data_path <- "/Users/vilkal/work/Brolidens_work/Projects/Candida-omics/Tidy_data/Metagenomics/Metageonome_all_vagswab_metaphlan.csv"
meta_path <- "/Users/vilkal/Downloads/Metadata_svamp.xlsx"

#############
# LOAD DATA #
#############
data <- read_csv(data_path) 
meta_data <- read_xlsx(meta_path, sheet = "Metadata", skip = 1, na = "na")
```

```{r group-assignment}
gr_data <- meta_data %>%
    rename(`Symptom score (0-5)` = "Symptom score (0-5) - ibland har de svarat olika skriftligt i frågeformuläret och muntligt vid inklusiion, då har jag valt den högsta scoren") %>%
  select(
    svamp_ID,
    `Clinical score (0-5)`,
    `Fungal culture: C. albicans (y/n)`,
    `Fungal culture: Non-albicans candida spp. (y/n)`,
    `Symptom score (0-5)`,
    `Recurring fungal infections > 2/year (y/n)`
  ) %>%
    mutate(
  group = case_when(
    `Fungal culture: C. albicans (y/n)` == "1" &
      `Symptom score (0-5)` >= 1 &
      `Recurring fungal infections > 2/year (y/n)` == "1" ~
      "RVVCpos",

    `Fungal culture: C. albicans (y/n)` == "0" &
      `Recurring fungal infections > 2/year (y/n)` == "1" ~
      "RVVCneg",

    `Fungal culture: C. albicans (y/n)` == "1" &
      `Symptom score (0-5)` == 0 ~
      "AS",

    `Fungal culture: C. albicans (y/n)` == "0" &
      `Recurring fungal infections > 2/year (y/n)` == "0" ~
      "Control",

    `Fungal culture: C. albicans (y/n)` == "1" &
      `Recurring fungal infections > 2/year (y/n)` == "0" ~
      "Candidapos",

    TRUE ~ NA_character_
  )
) %>%
  select("svamp_ID", group, everything())


```


## Step 2: Pre-filtering
keep taxa with at least 0.005% in at least 6% (6 out of 93) of samples, or at least 2% relative abundance in at least 1 sample.

```{r filter-taxa}
# final
############################
# IDENTIFY TAXA TO FILTER #
###########################
t <- set_names(taxonomy, seq_along(taxonomy))
data <- data %>%
    select( -contains("ex"), -contains("seq"), -contains("_run2")) %>% # removes ctrl and extra samples
    select(-matches("_1W|_3M|_6M")) %>%
    mutate(
        level = factor(
            t[as.character(str_count(clade_name, "\\|") + 1)],
            levels = taxonomy),
            .after = "clade_name"
            ) 

n_samples <- select(data, starts_with("S")) %>% ncol() # number of good samples

# keep taxa with at least 0.005% in at least 6% (5 out of 84) of samples, or at least 2% relative abundance in at least 1 sample.

# Step 1. split clade name into seperate columns
temp <- data %>%
    separate(
    col = clade_name,
    into = taxonomy,
    sep = "\\|",
    #remove = FALSE,
    fill = "right"
  ) %>%
  # keeps any row where at least one numeric column has a value greater than zero
  filter(if_any(where(is.double), ~ .x > 0))

# Step 2. Identify the strains to remove
strains_to_remove <- temp %>%
  filter(level == "strain") %>%
  filter(
    !(rowSums(across(where(is.double), ~ .x > 0.005)) >=
      round(0.06 * n_samples) |
      rowSums(across(where(is.double), ~ .x >= 2)) >= 1)
  )

# pander table of strains to remove
strains_to_remove %>%
  arrange(desc(rowSums(across(where(is.numeric))))) %>%
  # removes samples with colsum = zero:
  select(
    -where(~ is.numeric(.x) && sum(.x) == 0)
  ) %>%
  knitr::kable(., digits = 1)


# Step 3. Aggregate removed strains by higher levels
removed_all_lvls <- strains_to_remove %>%
  # pivot_longer(cols = where(is.double), names_to = "sample", values_to = "removed_abundance") %>%
  select(-level) %>%
  pivot_longer(
    cols = kingdom:strain,
    names_to = "level",
    values_to = "name"
  ) %>%
  nest(.by = c(level)) %>%
  mutate(
    data = purrr::map(
      data,
      ~ summarise(.x, across(where(is.double), ~ sum(.)), .by = c("name"))
    )
  ) %>%
  mutate(data = setNames(.[["data"]], .$level))

removed_all_lvls

knitr::kable(removed_all_lvls$data[[2]], digits = 1)


# Step 4. get longer format and add back clade_names
# function to get clade name
get_full_clade.fun <- function(df) {
  # This will add a new column called match_clade
  # with the full clade_name that ends with the string from tissue_renorm_filt$clade_name
  df %>%
    mutate(
      match_clade = map_chr(
        name,
        ~ {
          hit <- data$clade_name[str_detect(
            data$clade_name,
            paste0(.x, "$")
          )]
          if (length(hit) > 0) hit[1] else NA_character_
        }
      )
    ) %>%
    select(match_clade) %>%
    pull()
}

removals <- removed_all_lvls %>%
  unnest(cols = data) %>%
  mutate(clade_name = get_full_clade.fun(.))

#############################
# FILTER AT ALL TAXA LEVELS #
############################
# Step 5. Subtract from higher levels
data_filt <- data %>%
  # Join percentages to be subtracted
  left_join(
    select(removals, -name, -level),
    by = "clade_name",
    suffix = c("", "_rm")
  ) %>%
  # Subtract sample-wise values
  mutate(
    across(
      matches("^S\\d\\d$"),
      ~ .x - coalesce(get(paste0(cur_column(), "_rm")), 0)
    )
  ) %>%
  select(-ends_with("_rm"))

# --- Step 6: check and replace negatives ---
indx <- which(data_filt < 0, arr.ind = TRUE)

if (nrow(indx) > 0) {
  neg_report <- tibble(
    neg    = map2_dbl(indx[,1], indx[,2], ~ data_filt[[.x, .y]]),
    remove = map2_dbl(indx[,1], indx[,2], ~ data[[.x, .y]]),  # original value from data
    col    = map_chr(indx[,2], ~ colnames(data)[.x]),         # column name
    tax    = map_chr(indx[,1], ~ data[[.x, 1]])               # taxon/clade name
  )
  
  message("Negative values found and replaced with 0:")
  print(neg_report)

  # --- Step 7: replace negatives with zero ---
  data_filt <- data_filt %>%
  mutate(across(where(is.numeric), ~ pmax(.x, 0)))
}

# test
strains_to_remove %>% pull("S39") %>% sum(.)
data_filt %>% filter(level == "genus") %>% pull("S39") %>% sum(.)

#####################################
# RENORMALIZED FILTERED TAXA VALUES #
#####################################
# Step 6. Re-normalize so each sample sums to 100
data_filt_norm <- data_filt %>%
  group_by(level) %>%
  mutate(
    across(
      matches("^S\\d\\d$"),
      ~ .x * 100 / sum(.x, na.rm = TRUE)
    )
  ) %>%
  ungroup()

# test
data_filt_norm %>% filter(level == "genus") %>% pull("S39") %>% sum(.)

```

### Save filtered table
```{r save-filtered-table}
data_filt_norm %>%
  #select(-Pos_Seq_Ctrl) %>%
  arrange(level) %>%
  write_csv(
    .,
    "../Results/MixOmic/Metageonome_all_vagswab_metaphlan_taxa_filt.csv"
  )
# data_filt_norm <- read_csv("../Results/Tissue_QC/Metageonome_all_vagswab_metaphlan_taxa_filt.csv")
```


## Step 3: Centered Log Ratio (CLR) Transformation
For technical, biological and computational reasons, microbiome data is compositional such that they represent proportions or relative information. Proportional data are restricted to a space where the sum of all OTU proportions for a given sample sums to 1. Using standard statistical methods on such data may lead to spurious results. Likewise, any data that are compositional in nature are interpreted into relative counts. Hence, using a CLR transformation allows the circumvention of these spurious results.

There are two ways of log-ratio transforming the data in mixOmics:

  - Option 1: Some of our functions (pca, plsda) directly include the argument logratio = 'CLR', so all you need to do is include your filtered offset data and add this argument (see example below).
  - Option 2: Some functions currently do not include the logratio argument. In this case, you will need to use the logratio.transfo() function as shown below. You can also use this function if you only have access to TSS (proportions) data and those were not offset.

unlike 16S data which are returned as raw counts after pre-processing, shotgun metageome data is often already normalized into proportions. This is because direct counts aren’t very meaningful across different taxa/genomes. That is why we will go with option 2 for our data.

### Shotgun metagenomics

- You sequence **all DNA** in the sample, not just one marker gene.  
- Reads are mapped to **reference genomes, genes, or functional categories**.  
- Raw counts can be biased by factors like:
  - genome size  
  - gene length  
  - variable sequencing depth  
- Because of this, many sequencing facilities preprocess shotgun data to produce **normalized relative abundances (proportions)**, so that samples can be compared more easily.  

**Typical outputs include:**  
- Relative abundance (%) of taxa  
- RPKM / TPM / CPM for genes or functions 


## Step 3: Simplify clade names

Now we want to simplify the `clade_name` column so that:

- For **phylum / class / order / family / genus**, only the relevant level is kept.
- For **species** and **strain**, all levels are incuded down from genus,  
  i.e. `"Genus species"` or `"Genus species strain"`.
```{r simplify-clade_name}
# string manipulation

# data_filt_norm <- read_csv("../Results/Tissue_QC/Metageonome_all_vagswab_metaphlan_taxa_filt.csv")

# Modify taxa labels 
data_filt_norm <- data_filt_norm %>%
  mutate(
    taxa = str_extract_all(clade_name, "(?<=k__|p__|c__|o__|f__|g__|s__|t__)[^|]+"),
    taxa = map2_chr(taxa, level, ~ {
      if (.y %in% c("species", "strain")) {
        # keep everything from genus onward
        start <- which(c("k","p","c","o","f","g","s","t") %in% substr(.y,1,1))
        paste(.x[start:length(.x)], collapse = " ")
      } else {
        # keep only the last element (current level)
        tail(.x, 1)
      }
    }),
    .after = "level"
  ) %>%
  select(-clade_name) %>%
  rename(clade_name = taxa)
```


## Step 4: Centered Log Ratio (CLR) Transformation

```{r create-matrix}
# Create matrix for all levels of taxa
# NB! the majority(?) of mixOmics functions expect a format of
# samples as rows and features as columns, thus the transformation 
# is VERY important!
matrix <- data_filt_norm %>%
    #rename_with(~ str_replace(.x, "_BL$", ""), everything()) %>%
    nest(data = -level) %>%
    # filter(level == "strain") %>%
    mutate(
    data = map(
      data,
      ~ .x %>%
        column_to_rownames(var = "clade_name") %>%
        as.matrix() %>%
        t()
    )
  )

matrix


```

```{r normalize}
# Specify levels you want to process
tax_levels <- c("order", "family", "genus", "species", "strain")


matrix <- matrix %>%
  # Apply CLR transformation and PCA to each level
  mutate(
    clr_data = map(data, ~ logratio.transfo(.x, logratio = "CLR", offset = 1))
  ) %>%
    mutate(across(2:3, ~set_names(.x, paste0(.data[["level"]]))))


```

```{r save-CLR-transformed-data}
write_csv(
  matrix,
  "../Results/MixOmic/Metageonome_vagswab_CLR_transformed.csv"
)
# matrix <- read_csv("../Results/MixOmic/Metageonome_vagswab_CLR_transformed.csv")
```

## Step 5: Exploratory Unsupervised PCA

```{r get-new-groups}
g <- c("0"="0-1", "1"="0-1", "2"="2-3", "3"="2-3", "4"="4-5", "5"="4-5")
gr <- tibble(ID = colnames(data)[-c(1,2)]) %>% 
    left_join(., gr_data, by =c("ID"="svamp_ID")) %>%
    mutate(
      pos = case_when(
        `Fungal culture: C. albicans (y/n)` == "1" |
        `Fungal culture: Non-albicans candida spp. (y/n)` == 1 ~
        "pos",
        TRUE ~ "neg"
        ), .after="group") %>%
    mutate(`Clinical score (0-5)` = as.character(.$`Clinical score (0-5)`)) %>%
    mutate(Clin_gr = g[.$`Clinical score (0-5)`], .after ="group") #%>%
    #filter(!(is.na(.$Clin_gr)))

```


```{r plot-PCA}
#| output: false
matrix <- matrix %>%
  # Filter matrix to only these levels
  filter(level %in% tax_levels) %>%
  
  # Apply CLR transformation and PCA to each level
  mutate(
    #clr_data = map(data, ~ logratio.transfo(.x, logratio = "CLR", offset = 1)),
    pca_res  = map(clr_data, ~ pca(.x)),
    plot = map2(pca_res, level, ~plotIndiv(.x, col = pal,
                group = gr$Clin_gr, ind.names = F, size.title = 9,
                title = paste0(.y))),
    plot2 = map2(pca_res, level, ~plotIndiv(.x, col = pal2,
                group = gr$`Clinical score (0-5)`, ind.names = F, size.title = 9,
                title = paste0(.y)))
  ) %>%
    mutate(across(2:5, ~set_names(.x, paste0(.data[["level"]]))))

# Plot PCA for selected levels
l <- get_legend(plotIndiv(matrix$pca_res[["genus"]], col = pal, legend = T, group = gr$Clin_gr)$graph)
l2 <- get_legend(plotIndiv(matrix$pca_res[["genus"]], col = pal2, legend = T, group = gr$`Clinical score (0-5)`)$graph)
p <- matrix$plot %>% map("graph")
p2 <- matrix$plot2 %>% map("graph")

```

```{r plot-panels}
#| fig-width: 10
#| fig-height: 7
plot_grid(
  plotlist = c(list(l),p),
  #labels = matrix$level,   # use taxonomy levels as labels
  ncol = 3
)

plot_grid(
  plotlist = c(list(l2),p2),
  #labels = matrix$level,   # use taxonomy levels as labels
  ncol = 3
)
```

There are no clear seperation between the labels at any of the taxa levels.
A google search indicate that Some studies find family or genus level is often most informative.
Im wondering weather I can combine the matrix for genus and species level and to the PLS-DA on that?


Now that the data is:

- filtered for low abundant taxa  
- CLR transformed  
- offset added  

Now we can move on to the Feature selection (PLS-DA)
For this portion of the script we are following the MixOmics tutorial here:
https://mixomics.org/mixmc/koren-bodysites-case-study/


## Step 6: Exploratory Heatmap

```{r heatmap-matrix}
library(ComplexHeatmap)
library(circlize)

# no need to scale or center abundance data as this inherently in percent:
# we only need to log transforme the data and add a off-set
# I dont know if it is more appropriate to use abundanc or CLR normalized data

# CLR
matrix.h <-  matrix$clr_data$species %>% t()  

# log abundance
# matrix.h <- matrix.h + 0.0001 %>% log2()

# Filter
matrix.h <- matrix.h[,gr$ID]

top <- sort(rowSums(t(matrix$data$species)), decreasing = T)[1:50]
matrix.h <- matrix.h[names(top),]

dim(matrix.h)
```

```{r heatmap-annotation}
##############
# ANNOTATION #
##############
# colour pallets
blue <- brewer.pal(6, name = "Blues") 
purple <- brewer.pal(6, name = "Purples") 
reds <- brewer.pal(6, name = "Reds")

Red <- brewer.pal(6, name = "Reds") %>% c(., "gray") 
pal <- c("#f26386",  "#a4d984", "#fbbc52", "gray") # "#f588af", "#fd814e" 
pal2 <- c("#2266ac", "#91c5de", "gray")

# group information 
cols <- c("Clin_gr", "Clinical score (0-5)", "Fungal culture: C. albicans (y/n)") %>% set_names()
lvls <- map(cols, ~ c(sort(unique(gr[[.x]])), "na"))

annot_col <- gr %>%
  mutate(across(all_of(cols),
                ~ factor(.x, levels = lvls[[cur_column()]])))

# check samples number
dim(matrix.h)
dim(annot_col)

# top annotation object:
top_annot <- columnAnnotation(
  Groups = annot_col$Clin_gr,
  Clin = annot_col$`Clinical score (0-5)`,
  Culture = annot_col$`Fungal culture: C. albicans (y/n)`,
  #show_legend = FALSE,
  show_annotation_name = T,
  annotation_name_gp = gpar(fontsize = 8),
  annotation_legend_param = list(
    grid_height = unit(.1, "mm"), 
    grid_width = unit(2, "mm"), 
    title = "", labels_gp = gpar(fontsize = 7), 
    title_gp = gpar(fontsize = 8)),
  simple_anno_size = unit(.3, "cm"),
  #gap = unit(1, "cm"),
  col=list( Clin=set_names(Red, levels(annot_col$`Clinical score (0-5)`)),
            Groups=set_names(pal, levels(annot_col$Clin_gr)),
            Culture=set_names(pal2, levels(annot_col$`Fungal culture: C. albicans (y/n)`)))
            )

```



```{r heatmap-color-scale}
#| fig-cap: "Figure 3: Histogram showing the distribution of z-score normalized matrix values"
################
# PLOT HEATMAP #
################
# colour mapping
breaks.fun <- function(min, max, n){
  x <- seq(min, max, length.out = n)
  x[which(x == median(x))] <- 0
  round(x)
  return(x)}

q <- quantile(matrix.h, probs = seq(0, 1, 0.1))
# to better know what values to use for the legend
# we use the quantile() function to get appropriate limits
# we plot the distribution of values 
# Convert to a data frame for ggplot
df <- data.frame(value = as.vector(matrix.h))

# Basic ggplot histogram
ggplot(df, aes(x = value)) +
  geom_histogram( fill = "skyblue", color = "skyblue") +
  #scale_x_continuous(breaks = scales::breaks_pretty(n = 20)) +
  #scale_y_continuous(labels = label_comma()) + # <-- commas
  labs(
    title = "Distribution of Matrix Values",
    x = "Matrix Values",
    y = "Count"
  ) +  
  theme_minimal(base_size = 14)

# plot to better see the outlier values
ggplot(df, aes(x = value)) +
  geom_histogram(fill = "skyblue", color = "skyblue") +
  #scale_x_continuous(breaks = scales::breaks_pretty(n = 20)) +
  labs(
    title = "Distribution of Matrix Values",
    x = "Matrix Values",
    y = "Count"
  )  + ylim(0,10) +
  theme_minimal(base_size = 14)

# set limits for colourpallet
RdBu = c("#364B9A", "#4A7BB7", "#6EA6CD", "#98CAE1", "#C2E4EF", "white", "#FEDA8B", "#FDB366", "#F67E4B", "#DD3D2D", "#A50026")

# using min and max from the matrix matrix can work, but is usualy influenced too much 
# from the min and max values which tend to be outliers
# col <- colorRamp2(breaks.fun(min(matrix.h), max(matrix.h), 7), colorRampPalette(c(RdBu))(7))

# instead we use the historgram to determine the min and max values of the scale
# values larger than 5 are all mapped to dark red and values less than -5 are all mapped to dark blue.
# col <- colorRamp2(breaks.fun(q["25%"], -q["25%"], 7), colorRampPalette(c(RdBu))(7))
```

based on these histograms we can set the scale max and min breaks at 5

```{r plot-heatmap}
#| fig-width: 10
#| fig-height: 7
#| fig-cap: "Figure 5: Hierarchial clustering of differentially expressed genes. Heatmap of all 7,983 DEGs (FDR-adjusted p value <0.05) between the Clinical score values 5 and 4 (n = 14) and Clinical score values 0 and 1 CTRL (n = 108) group. Each study participant is represented by a vertical column and each gene is represented by a horizontal row. The expression of each gene is standardized (z) to a mean of 0 and a standard deviation of 1."

################
# PLOT HEATMAP #
################
# Heatmap global options:
ht_opt$COLUMN_ANNO_PADDING = unit(.05, "cm")
ht_opt$HEATMAP_LEGEND_PADDING = unit(-0, "cm") #unit(c(0, 0, 0, -1), "cm") #b,l,t,r
ht_opt$TITLE_PADDING = unit(.05, "cm")
ht_opt$DIMNAME_PADDING = unit(.05, "cm")

# average expression:
H <- Heatmap(matrix.h,
             col = blue, 
             cluster_columns = TRUE,
             show_row_dend = FALSE,
             name="CLR", 
             show_row_names = T, 
             show_column_names = TRUE, 
             column_names_gp = grid::gpar(fontsize = 8),
             row_names_gp = grid::gpar(fontsize = 8),

            # annotation
             # right_annotation = right_anno_row, left_annotation = left_anno_row,
             top_annotation = top_annot
                                          ) 
H

pdf(file = "./Heatmap_gene_expression.pdf", width = 10, height = 7)
H
dev.off()
```