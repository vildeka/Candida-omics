---
title: "Transcriptomics Normalization and Exploration"
date: today
date-format: "D MMM YYYY"
format:
  html: 
    embed-resources: true
    toc: true
    toc-depth: 2
    highlight-style: github
    code-tools:
      source: true
      toggle: true
      caption: Code
---

## Overview: 
#### Quality Control and Normalization

0. **Sample Information**  

1. **Metadata and group assignment**  

2. **Normalize counts with TMM**

3. **Gene-filtering**  
   Identify treshold for low abundant genes to filter

4. **Compare re-sequenced samples**

5. **Differential Gene Expression analysis**

6. **Exploratory Heatmap**

7. **UMAP on signifcant genes**

### Load Libraries
```{r Libraries}
#| code-fold: true
#| output: false
##################
# LOAD LIBRARIES #
##################
library(tidyverse)
# BiocManager::install("limma")
# BiocManager::install("edgeR")
# BiocManager::install("ComplexHeatmap")
library(limma)
library(edgeR)

library(scales)
library(ComplexHeatmap)
library(circlize)
library(mixOmics) 
library(readxl)
library(cowplot)
library(RColorBrewer)

select <- dplyr::select
map <- purrr::map

# setwd("/Users/vilkal/work/Brolidens_work/Projects/Candida-omics/src")

```

## Sample Information

There are only two biopsies collected in the longitudinal study —  
at **visit 02** and **visit 04**, corresponding to **baseline** and the **3-month follow-up**.

#### Longitudinal Study Setup

#### Visits:
- **01** – Inclusion  
- **02** – Secretion + biopsy (**baseline**)  
- **03** – Secretion only (**1 week post-treatment**)  
- **04** – Secretion + biopsy (**3 months post-treatment**)  
- **05** – Secretion only (**6 months post-treatment**)

#### Sequencing Runs

The samples have been run in two sequencing batches:

- **Run 1:** `BEA23P074_23`  
- **Run 2:** `BEA24P003_28`

#### Sample Summary

Based on the files delivered from BEA, I believe we have sequenced:  
**81 unique samples**, of which **73 are baseline** and **8 are 3-month follow-up**.

NB! The baseline sample of **(S69)** has `12:01` (DS_ID) listed as baseline instead of `12:02`.
This was a mistake, but we decided to keep it. 

#### Potential Control Samples

There are six samples that might be **controls**, but this is uncertain.  
I could not find any documentation explaining their naming:

FF060322243, FF060322244, 231025:1, 230918., 231108:1, 231108:1

```{r Load-data}
#| code-fold: true
#| output: false
#############
# LOAD DATA #
#############
meta_path <- "/Users/vilkal/Downloads/Metadata_svamp.xlsx"
meta_path <- "/Users/vilkal/work/Brolidens_work/Projects/Candida-omics/data/Metadata_svamp_FINAL.xlsx"
meta_data <- read_xlsx(meta_path, sheet = "Metadata", skip = 1)
meta_data <- read_xlsx(meta_path, sheet = "Metadata")

trx_path <- "../Tidy_data/Transcriptomics/Counts_all_trx_samples.csv"
raw_matrix <- read_csv(trx_path)
```

## Step 1: Metadata and group assignment
```{r group-assignment}
#| code-fold: true
g <- c("0"="0-1", "1"="0-1", "2"="2-3", "3"="2-3", "4"="4-5", "5"="4-5")

gr_data <- meta_data %>%
    rename(`Symptom score (0-5)` = "Symptom score (0-5) - ibland har de svarat olika skriftligt i frågeformuläret och muntligt vid inklusiion, då har jag valt den högsta scoren") %>%
  select(
    svamp_ID,
    `Age (years)`,
    `Clinical score (0-5)`,
    `Fungal culture: C. albicans (y/n)`,
    `Fungal culture: Non-albicans candida spp. (y/n)`,
    `Symptom score (0-5)`,
    `Recurring fungal infections > 2/year (y/n)`
  ) %>%
  filter(!(is.na(svamp_ID))) %>%
    mutate(
  group = case_when(
    `Fungal culture: C. albicans (y/n)` == "1" &
      `Symptom score (0-5)` >= 1 &
      `Recurring fungal infections > 2/year (y/n)` == "1" ~
      "RVVCpos",

    `Fungal culture: C. albicans (y/n)` == "0" &
      `Recurring fungal infections > 2/year (y/n)` == "1" ~
      "RVVCneg",

    `Fungal culture: C. albicans (y/n)` == "1" &
      `Symptom score (0-5)` == 0 ~
      "AS",

    `Fungal culture: C. albicans (y/n)` == "0" &
      `Recurring fungal infections > 2/year (y/n)` == "0" ~
      "Control",

    `Fungal culture: C. albicans (y/n)` == "1" &
      `Recurring fungal infections > 2/year (y/n)` == "0" ~
      "Candidapos",

    TRUE ~ NA_character_
  )
)  %>%
    mutate(
      pos = case_when(
        `Fungal culture: C. albicans (y/n)` == "1" |
        `Fungal culture: Non-albicans candida spp. (y/n)` == 1 ~
        "pos",
        TRUE ~ "neg"
        ), .after="group") %>%
    mutate(Clin_gr = g[as.character(.$`Clinical score (0-5)`)], .after ="group") %>%
  select("svamp_ID", group, everything())

```

### Check the distribution of samples per groups
```{r group-distribution}
table(gr_data$`Clinical score (0-5)`)
table(gr_data$Clin_gr)
```

### Get count table
```{r get-count-table}
# remove quality controll samples
# assuming that the NA_1-6 samples are quality ctrls, 
# we remove them before normalizing and filtering
countTable <- raw_matrix %>%
  select(-starts_with("NA")) # %>%
  #select(-ends_with("_run2"))

# Create matrix countTable 
countTable <- countTable %>%
  select(-c(1:6), -entrez) %>%      # remove metadata columns
  filter(!is.na(symbol)) %>%         # remove rows without a symbol
  filter(if_any(where(is.numeric), ~ . != 0)) %>%  # remove rows that are all zeros
  summarise(across(where(is.numeric), \(x) sum(x, na.rm = TRUE)), .by = "symbol") 

```

```{r number-of-samples}
# number of uniqe samples excluding "_run2" samples
samples <- select(countTable, where(is.numeric) & !( matches("_run2$"))) %>% colnames()
length(samples)

```

## Step 2: Normalize counts with TMM 

```{r Normalized-data}
#| eval: true

# get normalized matrix
# Create DGElist object to relate counts to groups
dge <- countTable %>%
  column_to_rownames(., var = "symbol") %>%
  DGEList(.)

# Normalize counts with TMM 
dge_TMM <- calcNormFactors(dge, method = "TMM")

```


## Step 3: Gene-filtering

### Alternative 1:
We calculate the mean log2 CPM of each gene to determine what filtering cuttof to use. 
By looking at the histogram of the mean log2 CPM values you can determine what log2 CPM value would be suitable to use. You want to see a normal distribution of the mean log2 values. In this dataset vi see that there are a higer frequency of genes around log2CPM between 1 and 2 than what you would expect from the normal distribution. 

```{r count-distribution-plot}
#| fig-cap: "Figure 1: Histogram of mean log2 CPM expression per gene. The vertical gray dashed line marks 1.5 log2 cpm"

# Identify low count cut-off
meanLog2CPM <- rowMeans(log2(cpm(countTable[,-1]) + 1))
# hist(meanLog2CPM)
ggplot() +
    geom_histogram(aes(meanLog2CPM), 
      fill = "red", alpha = 0.7, bins = 50) +
    theme_minimal() +
    scale_y_continuous(labels = label_comma()) + # <-- commas
    geom_vline(xintercept = 1.5, color = "gray", linetype = "dashed") +
    ggtitle("Distribution of Mean log2 CPM") 

# number of genes that will be removed:
s <- sum(meanLog2CPM <= 1.5) 

# knitr::kable(., digits = 1)
# Alternative 1.
genes_keep_1 <- countTable %>%
  filter(rowMeans(across(any_of(samples))) > 1.5) %>%
  pluck(., "symbol")
  
countTable %>%
  mutate(meanLog2CPM = rowMeans(across(any_of(samples))),.after="symbol") %>%
  mutate(cumulative_sum = rowSums(across(any_of(samples))),.after="symbol") %>%
  filter(meanLog2CPM < 1.5) %>%
  arrange(desc(cumulative_sum)) %>%
  select(1:3)
```

A cuttof at 1.5 seem to be appropriate and would result in the removal of `{r} s` genes. 

### Alternative 2:
Another aproach is to filter genes by setting a minimum treshold of counts per million

Keep genes where CPM > 1 in more than 3 samples
```{r identify-genes-to-remove}
# Alternative 2.
# get counts per mullion (CPM) not logged, for filtering:
cpm_TMM <- cpm(dge_TMM, log=FALSE)

genes_keep_2 <- cpm_TMM %>%
  as_tibble(., rownames = "symbol") %>%
  filter(rowSums(across(all_of(samples), ~ .x >= 1)) >= 3) %>%
  pluck(., "symbol")

# look at top filtered genes
cpm_TMM %>%
  as_tibble(., rownames = "symbol") %>%
  filter(!(symbol %in% genes_keep_2)) %>%
  mutate(n_over_1cpm = rowSums(across(all_of(samples), ~ .x >= 1)), .after="symbol") %>%
  mutate(sum_cpm = rowSums(across(all_of(samples))), .after = "symbol") %>%
  filter(n_over_1cpm < 3) %>% 
  arrange(desc(n_over_1cpm)) %>%
  select(1:3)

length(genes_keep_1)
length(genes_keep_2)
length(intersect(genes_keep_1, genes_keep_2))

```

Alternative one is less conservative presarving more lowly expressed genes. 
Alternative 2 is more sensitive. 
We go for alternative 2 as more than 16 000 genes is more than enough.

```{r filter-genes}
# Step 3. filter low abundant genes
# DEGlist object
dge_TMM_filt <- dge_TMM[genes_keep_2,]

# count table
countTable_filt <- countTable %>%
  filter(symbol %in% genes_keep_2)

```

```{r save-mormalized-data}
########################
# SAVE NORMALIZED DATA #
########################
cpm_log_TMM <- cpm(dge_TMM_filt, log=T) # for heatmap 

cpm_log_TMM %>%
  as_tibble(., rownames = "symbol") %>%
  write_csv(., "../Results/MixOmic/Transcriptomics_Normalized.csv")
# norm <- read_csv("../Results/MixOmic/Transcriptomics_Normalized.csv")
```

## Step 4: compare re-sequenced samples

```{r compare-re-sequenced-samples}
#| fig-width: 10
#| fig-height: 8
#| fig-cap: "Figure 3: Comparison of technical replicates across sequencing runs. Scatterplots show log₂-transformed CPM values for the same biological samples sequenced in two independent sequencing runs. Each point represents one gene. The dashed red line indicates the 1:1 relationship expected for perfect agreement between runs. Overall, the replicate samples display high concordance, confirming that technical variation between sequencing runs is minimal relative to biological signal.  Pearson and Spearman correlation coefficients were calculated for each sample pair and are summarized in the accompanying table."
#| code-fold: false
#| eval: true

#############################
# PLOT RE-SEQUENCED SAMPLES #
#############################
n <- names(select(countTable, contains("_run2")))
samp <- str_remove(n, "_run2")
n <- c(n, samp) # samples sequenced twice

# Create a tidy summary comparing all pairs
pair_summary <- map_dfr(samp, function(samp) {
  run1 <- cpm_log_TMM[, samp, drop = TRUE]
  run2 <- cpm_log_TMM[, paste0(samp, "_run2"), drop = TRUE]

  tibble(
    sample = samp,
    pearson = cor(run1, run2, method = "pearson"),
    spearman = cor(run1, run2, method = "spearman"),
    mean_diff = mean(run1 - run2),
    sd_diff = sd(run1 - run2)
  )
})

pair_summary

# generate one plot per pair
air_plots <- map(samp, function(samp) {
  df <- tibble(
    gene = rownames(cpm_log_TMM),
    run1 = cpm_log_TMM[, samp],
    run2 = cpm_log_TMM[, paste0(samp, "_run2")]
  )
  
  ggplot(df, aes(x = run1, y = run2)) +
    geom_point(alpha = 0.3) +
    geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "red") +
    labs(title = paste("Comparison:", samp), x = "Run1 log2-CPM", y = "Run2 log2-CPM") +
    theme_minimal()
}) %>%
  set_names(samp)

cowplot::plot_grid(plotlist = air_plots, ncol = 2)
```

### Remove ctrl and second run samples

```{r filter-samples}
countTable_final <- countTable_filt %>%
  # remove samples sequenced twice
  select(-ends_with("_run2")) %>%
  # remove controll samples
  select(-starts_with("NA"))

```


## Step 5: Differential Gene Expression analysis

```{r functions}
##################
# DEG's FUNCTION #
##################
# df <- meta_trx
# sample_df <- gr_data
# group <- "Clin_gr"

edgR_dge.fun <- function(CountMatrix, gr, sample_df, confound = NULL) {
  
  #groups <- sample_df[, group]
  groups <- pull(sample_df, gr)
  n_gr <- length(na.omit(unique(groups)))
  
  if(any(is.na(groups))) {
    groups <- tidyr::replace_na(groups, "X")
  }

  if(!is.null(confound)) {
    c <- "_conf"
    design <- design
  }else{
    c <- "_no_conf"
    design <- model.matrix(~groups, data=sample_df) # without confounders
  }
  
  colnames(design) <- sub(gr,"",colnames(design))
  colnames(design) <- sub("\\(Intercept\\)","Intercept",colnames(design))
  colnames(design) <- sub(" ","_",colnames(design))
  
  y <- DGEList(counts=CountMatrix, remove.zeros = T)
  y <- calcNormFactors(y,method = "TMM")
  y <- estimateGLMCommonDisp(y,design)
  y <- estimateGLMTagwiseDisp(y,design)
  fit <- glmFit(y, design)
  
  lrt <- glmLRT(fit,coef=2:n_gr) # with intercept
  top <- topTags(lrt,adjust.method = "BH",n = "all",sort.by = "p.value")[[1]]
  colnames(top) <- sub(gr,"",colnames(top))
  top <- cbind(LogFC.intercept=0,top) # with intercept
  top <-  rownames_to_column(top, var = "Genes")
  
return(list(design=design, y=y, fit=fit, lrt=lrt, top=top, c=c))
}
```

```{r dge-analysis}
# Check consitency between group info and samples
samples <- colnames(countTable_final)
intersect(samples, gr_data$svamp_ID)
setdiff(samples, gr_data$svamp_ID)


gr <- c("0-1", "2-3", "4-5")

gr_data <- gr_data %>%
  filter(svamp_ID %in% samples) %>%
  mutate(Clin_gr = factor(.$"Clin_gr", levels = gr))

# nesscary only if you want to add confounders
design <- model.matrix(~Clin_gr+`Age (years)`,
                         data=gr_data)

dge <- column_to_rownames(countTable_final, var = "symbol") %>%
  edgR_dge.fun(., "Clin_gr", gr_data, confound=NULL)
```

```{r top-DEG}
# get DEGs for clin score 4-5
DEGs <- dge$top %>%
  as_tibble(.) %>%
  mutate(Regulation = 
        ifelse(`logFC.groups4.5` > 0 & FDR < 0.05, "UP",
          ifelse(`logFC.groups4.5` < 0 & FDR < 0.05,"DOWN", "NOT SIG."))) %>%
  filter(Regulation == "UP" | Regulation == "DOWN") 
  

DEGs %>%
  dplyr::select(-LogFC.intercept, -logFC.groups2.3) %>%
  group_by(Regulation) %>%
  slice_max(order_by = abs(logFC.groups4.5), n = 10) %>%
  arrange(`logFC.groups4.5`) %>%
  knitr::kable(., digits = 1)
```

## Step 6: Exploratory Heatmap

```{r get-matrix}
###############
# GET MATRIX #
###############
# get DEGs for clin score 4-5
DEGs  %>%
  dplyr::select(Genes, logFC.groups4.5) %>%
  arrange(`logFC.groups4.5`)

# get filter genes from normalized matrix
deg_matrix <- cpm_log_TMM[DEGs$Genes, gr_data$svamp_ID]

```


```{r z-scores}
# z-scores
# to scale the expression of our genes, we have to
# first transpose our matrix, then scale, then transpose it back:
zscore <- t(apply(deg_matrix, 1,function(i){scale(i, center = T, scale =T)}))
colnames(zscore) <- colnames(deg_matrix)

# tidyverse way:
# zscore <- cpm_log_TMM %>%
#   as_tibble(rownames = "symbol") %>% 
#   rowwise() %>%
#   mutate(across(-symbol, ~ as.numeric(scale(.x, center = TRUE, scale = TRUE)))) %>%
#   ungroup() %>%
#   column_to_rownames("symbol")

```

```{r heatmap-annotation}
##############
# ANNOTATION #
##############
# colour pallets
blue <- brewer.pal(6, name = "Blues") %>% c(., "gray") 
Red <- brewer.pal(6, name = "Reds") #%>% c(., "gray") 
pal <- c("#f26386",  "#a4d984", "#fbbc52") # "#f588af", "#fd814e" 
pal2 <- c("#2266ac", "#91c5de")

#Red <- brewer.pal(6, name = "Reds") #%>% c(., "gray") 
pal1 <- c("#ffa998", "#f588af","#902267") # 
pal3 <- c("#9e8dec","#902267","#cc93cf","#a5c97b","#de9548") #"#abcb4b" "#63d3b4"

# group information
annot_col <- gr_data %>%
  select(-`Age (years)`) %>%
  mutate(across(c(2,3),
                ~ factor(.x)))

# check samples number
dim(zscore)
dim(annot_col)

# top annotation object:
top_annot <- columnAnnotation(
  bin_Clin = annot_col$Clin_gr,
  Clin = annot_col$`Clinical score (0-5)`,
  Groups = annot_col$group,
  #show_legend = FALSE,
  show_annotation_name = T,
  annotation_name_gp = gpar(fontsize = 8),
  annotation_legend_param = list(
    grid_height = unit(.1, "mm"), 
    grid_width = unit(2, "mm"), 
    title = "", labels_gp = gpar(fontsize = 7), 
    title_gp = gpar(fontsize = 8)),
  simple_anno_size = unit(.3, "cm"),
  #gap = unit(1, "cm"),
  col=list( Clin=set_names(Red, levels(annot_col$`Clinical score (0-5)`)),
            bin_Clin=set_names(pal1, levels(annot_col$Clin_gr)),
            Groups=set_names(pal3, levels(annot_col$group)))
            )
```


```{r heatmap-color-scale}
#| fig-cap: "Figure 3: Histogram showing the distribution of z-score normalized matrix values"
#| fig-width: 10
#| fig-height: 5
################
# PLOT HEATMAP #
################
# colour mapping
breaks.fun <- function(min, max, n){
  x <- seq(min, max, length.out = n)
  x[which(x == median(x))] <- 0
  round(x)
  return(x)}

# to better know what values to use for the legend
# we plot the distribution of values 
# Convert to a data frame for ggplot
df <- data.frame(value = as.vector(zscore))

# Basic ggplot histogram
p <- ggplot(df, aes(x = value)) +
  geom_histogram(bins = 30, fill = "skyblue", color = "white") +
  #scale_x_continuous(breaks = scales::breaks_pretty(n = 20)) +
  scale_y_continuous(labels = label_comma()) + # <-- commas
  labs(
    title = "Distribution of Matrix Values",
    x = "Matrix Values",
    y = "Count"
  ) +
  theme_minimal(base_size = 14) #+
  #theme(axis.text.x = element_text(angle = 45, hjust = 1))

# plot to better see the outlier values
p2 <- p + ylim(0,5000) 

plot_grid(p, p2, ncol = 2)

# set limits for colourpallet
RdBu = c("#364B9A", "#4A7BB7", "#6EA6CD", "#98CAE1", "#C2E4EF", "white", "#FEDA8B", "#FDB366", "#F67E4B", "#DD3D2D", "#A50026")

# using min and max from the zscore matrix can work, but is usualy influenced too much 
# from the min and max values which tend to be outliers
col <- colorRamp2(breaks.fun(min(zscore), max(zscore), 7), colorRampPalette(c(RdBu))(7))

# instead we use the historgram to determine the min and max values of the scale
# values larger than 5 are all mapped to dark red and values less than -5 are all mapped to dark blue.
col <- colorRamp2(breaks.fun(-5, 5, 7), colorRampPalette(c(RdBu))(7))
```

based on these histograms we can set the scale max and min breaks at 5

```{r plot-heatmap}
#| fig-width: 10
#| fig-height: 7
#| fig-cap: "Figure 5: Hierarchial clustering of differentially expressed genes. Heatmap of all 7,983 DEGs (FDR-adjusted p value <0.05) between the Clinical score values 5 and 4 (n = 14) and Clinical score values 0 and 1 CTRL (n = 108) group. Each study participant is represented by a vertical column and each gene is represented by a horizontal row. The expression of each gene is standardized (z) to a mean of 0 and a standard deviation of 1."

################
# PLOT HEATMAP #
################
# Heatmap global options:
ht_opt$COLUMN_ANNO_PADDING = unit(.05, "cm")
ht_opt$HEATMAP_LEGEND_PADDING = unit(-0, "cm") #unit(c(0, 0, 0, -1), "cm") #b,l,t,r
ht_opt$TITLE_PADDING = unit(.05, "cm")
ht_opt$DIMNAME_PADDING = unit(.05, "cm")

# average expression:
H <- Heatmap(zscore,
             col = col, 
             cluster_columns = TRUE,
             show_row_dend = FALSE,
             name="Gene  \nExpression (z)", 
             show_row_names = FALSE, 
             show_column_names = TRUE, 
             column_names_gp = grid::gpar(fontsize = 8),

            # annotation
             # right_annotation = right_anno_row, left_annotation = left_anno_row,
             top_annotation = top_annot
                                          ) 
H
pdf(file = "./Heatmap_gene_expression.pdf", width = 10, height = 7)
H
dev.off()

```

## Step 7: UMAP on signifcant genes

```{r UMAP}
#### UMAP analysis ####
set.seed(1)
umap<-uwot::umap(t(deg_matrix), 
                 n_neighbors=15, init="spectral", scale=T)

umap_df <- tibble("UMAP 1"=umap[,1],"UMAP 2"=umap[,2], 
                  "ID"=rownames(umap)) %>%
          left_join(., annot_col, by=c("ID"="svamp_ID"))

#### UMAP plotting by groups ####
col <- c('#FB5273', "#6B51A3","#9D9AC8", '#4FCEEF',"#e68633")

txt_df <- umap_df %>% select(1:4) %>% mutate(txt = ifelse(group == "RVVCpos", .$ID, NA))

(p <- ggplot(umap_df, aes(x=`UMAP 1`, y=`UMAP 2`, fill=group))+ 
  #geom_jitter( shape=21, size=3, color="white", width=.5, height=.5) +  # Tassos used jitter
  geom_point( shape=21, size=3, color="white", alpha = .7) +  
  scale_fill_manual(values=pal3, name="group")+ 
  geom_text(data=txt_df, aes(x=`UMAP 1`, y=`UMAP 2`, label=txt), size=3,
            hjust = 0, nudge_x = 0.07, color="gray51") +
  theme_bw(base_size=14)+ 
  theme(line=element_blank(), 
        axis.ticks=element_line(color="black"), 
        aspect.ratio=1, axis.title=element_blank()) )

# save plot to file
dev.new(height=16.11, width=16.11, units="cm")
#ggsave(paste0("./Figures/09/", "Bulk_UMAP.png"), p)


```